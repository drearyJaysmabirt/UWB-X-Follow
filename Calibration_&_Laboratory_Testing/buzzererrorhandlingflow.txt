ðŸ”µ START (loop)
ðŸ”¹ Check for Jetson Command
â†’ Serial.available()?
â€ƒâ€ƒâ””â”€â”€ Yes â†’
â€ƒâ€ƒâ€ƒâ€ƒâ€¢ If "estop_activated" â†’ isFollowMode = false, LED OFF, reset UWB
â€ƒâ€ƒâ€ƒâ€ƒâ€¢ If "obstacle_detected" â†’ isObstacleDetected = true
â€ƒâ€ƒâ€ƒâ€ƒâ€¢ Else â†’ isObstacleDetected = false

ðŸ”¹ Check Button Press
â†’ Rising Edge (HIGH â†’ LOW)?
â€ƒâ€ƒâ””â”€â”€ Yes â†’
â€ƒâ€ƒâ€ƒâ€ƒâ€¢ Toggle isFollowMode
â€ƒâ€ƒâ€ƒâ€ƒâ€¢ Update LED
â€ƒâ€ƒâ€ƒâ€ƒâ€¢ resetAndInitializeUWB()

ðŸ”¹ Reset buzzerOverridden = false
ðŸ”µ IF isFollowMode == true
ðŸ”¹ Call processIncomingData()
â€ƒâ€ƒâ†’ Updates COM8, COM9, COM11 distances
â€ƒâ€ƒâ†’ Sets d1_updated, d2_updated, d3_updated

ðŸ”¹ Priority 1: UWB Failure
â†’ (any dX_updated) && millis() - lastDataTime > 2000?
â€ƒâ€ƒâ””â”€â”€ Yes â†’
â€ƒâ€ƒâ€ƒâ€ƒâ€¢ Set currentTone = UWB_FAILURE
â€ƒâ€ƒâ€ƒâ€ƒâ€¢ buzzerOverridden = true
â€ƒâ€ƒâ€ƒâ€ƒâ€¢ resetAndInitializeUWB()
â€ƒâ€ƒâ€ƒâ€ƒâ€¢ Reset dX_updated = false
â€ƒâ€ƒâ€ƒâ€ƒâ€¢ return (exit early)

ðŸ”¹ Priority 2: Obstacle Detected
â†’ isObstacleDetected == true?
â€ƒâ€ƒâ””â”€â”€ Yes â†’
â€ƒâ€ƒâ€ƒâ€ƒâ€¢ Set currentTone = OBSTACLE
â€ƒâ€ƒâ€ƒâ€ƒâ€¢ buzzerOverridden = true

ðŸ”¹ Priority 3: Out-of-Range
â†’ !buzzerOverridden && all dX_updated == true?
â€ƒâ€ƒâ””â”€â”€ Yes â†’
â€ƒâ€ƒâ€ƒâ€ƒâ€¢ calculateXYPosition()
â€ƒâ€ƒâ€ƒâ€ƒâ€¢ Distance >= 10?
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ””â”€â”€ Yes â†’
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€¢ currentTone = OUT_OF_RANGE
â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€¢ buzzerOverridden = true
â€ƒâ€ƒâ€ƒâ€ƒâ€¢ displayResults()
â€ƒâ€ƒâ€ƒâ€ƒâ€¢ generateFollowCommand()
â€ƒâ€ƒâ€ƒâ€ƒâ€¢ Reset dX_updated = false

ðŸ”¹ Priority 4: Heartbeat
â†’ !buzzerOverridden && currentTone == NONE && millis() - lastHeartbeatTime > 1000?
â€ƒâ€ƒâ””â”€â”€ Yes â†’
â€ƒâ€ƒâ€ƒâ€ƒâ€¢ currentTone = HEARTBEAT
â€ƒâ€ƒâ€ƒâ€ƒâ€¢ Update lastHeartbeatTime

ðŸ”¹ Compare currentTone != lastTone
â†’ If changed, reset buzzer parameters

ðŸ”¹ Call handleBuzzer()
â†’ Tone-specific behavior using non-blocking millis()-based timing

ðŸ”µ END loop â†’ Repeat
